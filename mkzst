#!/usr/bin/env python3
# 1.3.0
# 2020-05-10

# Copyright (C) 2020 Brandon Zorn <brandonzorn@cock.li>
#
# This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License version 3
#    as published by the Free Software Foundation.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program. If not, see <https://www.gnu.org/licenses/>.

import argparse
import atexit
import shutil
import tempfile
from pathlib import Path

from utils import utils


class Compress:
    def __init__(self):
        atexit.register(self.remove_tmpdir)

        self.__tmpdir = tempfile.mkdtemp()

        self.__cmd = None
        self.__ext = None

        self.__input_files = None

        self.__comp_type = None

        self.__directories = False
        self.__files = False
        self.__status = False

        self.__verbose = ''

        self.__destructive = False
        self.__destructive_files = False
        self.__destructive_directories = False

    def remove_tmpdir(self):
        shutil.rmtree(self.__tmpdir)

    def get_mode(self):
        if 'zst' in utils.get_script_name():
            self.__cmd = 'zstd -T0'
            self.__ext = 'zst'
        elif 'lz4' in utils.get_script_name():
            self.__cmd = 'lz4'
            self.__ext = 'lz4'
        elif 'xz' in utils.get_script_name():
            self.__cmd = 'xz -k -e9'
            self.__ext = 'xz'
        elif 'gz' in utils.get_script_name():
            self.__cmd = 'gzip -k'
            self.__ext = 'gz'
        elif 'bz2' in utils.get_script_name():
            self.__cmd = 'bzip2 -k'
            self.__ext = 'bz2'

    def get_files(self):
        if self.__directories or self.__files:
            for f in Path(Path.cwd()).iterdir():
                f = Path(f)
                if Path.is_dir(f) and self.__directories:
                    self.__comp_type = 'dir'
                    self.compress(file=f)
                if Path.is_file(f) and self.__files:
                    self.__comp_type = 'file'
                    self.compress(file=f)
        elif self.__input_files is not None:
            for f in self.__input_files:
                f = Path(f)
                if Path.is_file(f):
                    self.__comp_type = 'file'
                    self.compress(file=f)
                elif Path.is_dir(f):
                    self.__comp_type = 'dir'
                    self.compress(file=f)

    def compress(self, file):
        script = f'{self.__tmpdir}/tmp.sh'
        text = ''

        if self.__comp_type == 'dir' and self.__status:
            text += f'tar --xattrs -{self.__verbose}Scf - "{Path(file).name}" -P | ' \
                    f'pv -s "$(du -sb "{Path.resolve(file)}" | awk \'{{print $1}}\')" | ' \
                    f'{self.__cmd} >| "{Path(file).name}.tar.{self.__ext}" || die "Compression failed for: {file}"'

        elif self.__comp_type == 'dir':
            text += f'tar --xattrs -{self.__verbose}Scf - "{Path(file).name}" -P | ' \
                    f'{self.__cmd} >| "{Path(file).name}.tar.{self.__ext}" || die "Compression failed for: {file}"'

        elif self.__comp_type == 'file':
            text += f'{self.__cmd} "{file}" || die "Compression failed for: {file}"'

        utils.write_script_shell(script, text)
        utils.run_cmd(script)
        Path.unlink(Path(script))

    def run(self, args):
        # compression type
        if args.directories:
            self.__directories = True
        if args.files:
            self.__files = True
        if args.status:
            self.__status = True
        # destructive
        if args.destructive:
            self.__destructive = True
        if args.destructive_files:
            self.__destructive_files = True
        if args.destructive_directories:
            self.__destructive_directories = True
        # other
        if args.input_files is not None:
            self.__input_files = args.input_files
        if args.verbose:
            self.__verbose = 'v'

        self.get_mode()
        self.get_files()


def main():
    parser = argparse.ArgumentParser()
    general = parser.add_argument_group('GENERAL',
                                        'default is to compress files passed in $1')
    general.add_argument('input_files',
                         action='store',
                         type=str,
                         nargs='*',
                         default='',
                         help=argparse.SUPPRESS)
    general.add_argument('-d', '--directories',
                         action='store_true',
                         help='compress all directories')
    general.add_argument('-f', '--files',
                         action='store_true',
                         help='compress all files')
    general.add_argument('-s', '--destructive',
                         action='store_true',
                         help='compress $1, delete after compressed')
    general.add_argument('-S', '--status',
                         action='store_true',
                         help='enable cool status bar, directories only')
    general.add_argument('-v', '--verbose',
                         action='store_true',
                         help='enable verbose tar')
    general.add_argument('-x', '--destructive-files',
                         action='store_true',
                         help='compress all files, delete original after compressed')
    general.add_argument('-z', '--destructive-directories',
                         action='store_true',
                         help='compress all directories, delete original after compressed')
    args = parser.parse_args()

    utils.args_required_else_help()

    run = Compress()
    run.run(args)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        exit()
