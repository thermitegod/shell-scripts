#!/usr/bin/env sh
#5.1.0
#2019-03-28

#Copyright (C) 2018,2019 Brandon Zorn, brandonzorn@cock.li
#
#This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

#TODO
#xargs
#size target
#acceptable size range
#rezizing when w > h

convert_main(){
	if [ "${batch}" = "1" ];then
		batch="0"
		nest_dir=$(find . -mindepth 2 -path '*/*' -type d)
		if [ -n "${nest_dir}" ];then printf "Nested directories detected\n\n${nest_dir}\n\n";fi
		if [ "${mimecheck}" = "1" ];then mime-correct -A;mimecheck="0";fi
		for d in *;do
			if [ -d "${d}" ];then
				cd "${d}"
				printf "Running in: ${d}\n"
				convert_main "${1}"
				cd ..
			fi
		done
		exit
	fi
	if ! [ "${act}" = "get_size" ];then
		if [ "${mimecheck}" = "1" ];then mime-correct -I;fi
		mkdir -p "${O}"
		cvloc="cv_tmp"
		mkdir -p "${cvloc}"
	fi
	for f in *;do
		if [ -n "$(file -b --mime-type -- ${f%%}|grep image)" ];then
			case "${1}" in
				convert)
					gm convert -quality ${qual} "${f%%}" "${cvloc}/${f%.*}.${newext}"
					mv "${f}" "${O}"
					;;
				convert_auto)
					if [ "${newext}" = "jpg" ];then
						qual="100"
					else
						qual="9"
					fi
					if [ "${debug}" = "1" ];then iter="1";fi
					while true;do
						if [ "${debug}" = "1" ];then printf "iter ${iter}\n";fi
						gm convert -quality ${qual} "${f%%}" "${cvloc}/${f%.*}.${newext}"
						test_size "${f%%}" "${cvloc}/${f%.*}.${newext}"
						if [ "${new_smaller}" = "1" ];then
							new_smaller="0"
							printf "final qual is ${qual} for ${f}\n"
							mv "${f}" "${O}"
							break
						fi
						#runs when above if fails, so decrease $qual and try again
						qual=$((qual - 1))
						if [ "${debug}" = "1" ];then iter="$((iter + 1))";fi
					done
					;;
				resize)
					gm convert ${f%%} -resize "${size}"\> "${cvloc}/${f%%}"
					mv "${f}" "${O}"
					;;
				get_size)
					gm identify -format "%wx%h" "${f%%}"
					;;
			esac
		fi
	done
	if ! [ "${1}" = "get_size" ];then
		mv ${cvloc}/* . #do not quote
		rm -rf "${cvloc}"
		if [ "${keep_orig}" = "0" ];then rm -rf "${O}"
		elif [ -d "${O}" ] && ! [ "$(ls -A ${O})" ];then rm -rf "${O}"
		fi
	fi
}

test_size(){
	orig="${1}"
	new="${2}"

	if [ "${debug}" = "1" ];then
		echo "filesize new  : $(du ${new}|awk '{print $1}')"
		echo "filesize orig : $(du ${orig}|awk '{print $1}')"
	fi

	if [ "$(du ${orig}|awk '{print $1}')" -ge "$(du ${new}|awk '{print $1}')" ];then
		new_smaller="1"
	fi
}

get_mode(){
	if ! [ "${qual}" = "0" ];then
		act="convert"
	else
		act="convert_auto"
	fi
}

hlp(){
	printf "GENERAL\n"
	printf " -d\textra printouts\n"
	printf " -m\tdisable mime check\n"
	printf " -r\tdo not keep orig\n"
	printf " -s\tget current image size in dir\n"
	printf "\nBATCH\n"
	printf " example, $0 -B -P 0\n"
	printf " -B\tbatch, must come before other args\n"
	printf " -b\tbatch, must come before other args, uses -r\n"
	printf "\nRESIZE Width, keeps aspect\n"
	printf " -W *\tuse value provided\n"
	printf " -W 1\t2400x\n"
	printf " -W 2\t1600x\n"
	printf " -W 3\t1280x\n"
	printf " -W 4\t980x\n"
	printf " -W 5\t780x\n"
	printf "\nRESIZE Hight, keeps aspect\n"
	printf " -H *\tuse value provided, must prefix with 'x'\n"
	printf " -H 1\tx2400\n"
	printf " -H 2\tx1600\n"
	printf " -H 3\tx1280\n"
	printf " -H 4\tx980\n"
	printf " -H 5\tx780\n"
	printf "\nRESIZE Percent\n"
	printf " -S *\tuse value provided, must append '%%'\n"
	printf " -S 1\t90%%\n"
	printf " -S 2\t80%%\n"
	printf " -S 3\t70%%\n"
	printf " -S 4\t60%%\n"
	printf " -S 5\t50%%\n"
	printf "\nCONVERT\n"
	printf " -J [1-100]\tjpg > jpg : 100 quality=100 | 1 quality=1 | 0 sets auto mode\n"
	printf " -j [1-9]  \tjpg > png : 9   quality=9   | 1 quality=1 | 0 sets auto mode\n"
	printf " -P [1-9]  \tpng > png : 9   qualitl=9   | 1 quality=1 | 0 sets auto mode\n"
	printf " -p [1-100]\tpng > jpg : 100 quality=100 | 1 quality=1 | 0 sets auto mode\n"
}

O="orig"
mode="z"
batch="0"
debug="0"
mimecheck="1"
keep_orig="1"
new_smaller="0"

if [ -z "${1}" ];then hlp;exit;fi
while getopts "dP:p:J:j:H:W:S:hmsBbr" OPT;do
	case "$OPT" in
		j)
			origext="jpg"
			newext="png"
			qual="${OPTARG}"
			if [ "${qual}" -gt "9" ];then printf "exiting because of invalid range: ${OPTARG}\n";exit;fi
			get_mode
			;;
		J)
			origext="jpg"
			newext="jpg"
			qual="${OPTARG}"
			if [ "${qual}" -gt "100" ];then printf "exiting because of invalid range: ${OPTARG}\n";exit;fi
			get_mode
			;;
		p)
			origext="png"
			newext="jpg"
			qual="${OPTARG}"
			if [ "${qual}" -gt "100" ];then printf "exiting because of invalid range: ${OPTARG}\n";exit;fi
			get_mode
			;;
		P)
			origext="png"
			newext="png"
			qual="${OPTARG}"
			if [ "${qual}" -gt "9" ];then printf "exiting because of invalid range: ${OPTARG}\n";exit;fi
			get_mode
			;;
		W)
			case "${OPTARG}" in
				1) size="2400";;
				2) size="1600";;
				3) size="1280";;
				4) size="980";;
				5) size="780";;
				*) size="${OPTARG}";;
			esac
			act="resize"
			;;
		H)
			case "${OPTARG}" in
				1) size="x2400";;
				2) size="x1600";;
				3) size="x1280";;
				4) size="x980";;
				5) size="x780";;
				*) size="${OPTARG}";;
			esac
			act="resize"
			;;
		S)
			case "${OPTARG}" in
				1) size="90%";;
				2) size="80%";;
				3) size="70%";;
				4) size="60%";;
				5) size="50%";;
				*) size="${OPTARG}";;
			esac
			act="resize"
			;;
		B)
			keep_orig="0"
			batch="1"
			;;
		b)
			keep_orig="0"
			batch="1"
			;;
		r) keep_orig="0";;
		s) act="get_size";;
		m) mimecheck="0";;
		d) debug="1";;
		h) hlp;exit;;
	esac
done
#shift $((OPTIND - 1))

case "${act}" in
	convert)
		convert_main convert
		;;
	convert_auto)
		convert_main convert_auto
		;;
	resize)
		convert_main resize
		;;
	get_size)
		convert_main get_size
		;;
	*) printf "Nothing to do\n";exit;;
esac

