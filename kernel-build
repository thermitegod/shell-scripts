#!/usr/bin/env python3
# 2.7.0
# 2020-08-05

# Copyright (C) 2020 Brandon Zorn <brandonzorn@cock.li>
#
# This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License version 3
#    as published by the Free Software Foundation.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program. If not, see <https://www.gnu.org/licenses/>.

# ZFS Builtin Kernel Build Script - gentoo

# storage dirs - will be created
# ${XDG_DATA_DIRS}/kernel/{distfiles,kernels}

# assumptions
# /usr/src/linux is real source or symlink to real source

# What this script does, basically

# if no preconfigured sources exist for sys-fs/zfs-kmod ebuild
# runs configure phase on sys-fs/zfs-kmod ebuild
# saves portage work/ to tar.zst file in $kmod_src
# installs configured kmod-zfs to /usr/src/linux
# build kernel

# if preconfigured sources exist for ebuild sys-fs/zfs-kmod
# moves saved work/ in tar.zst file to /usr/src/linux
# build kernel

import argparse
import atexit
import multiprocessing
import os
import shutil
import tempfile

from pathlib import Path
from packaging import version

from utils import kernel
from utils import utils


# TODO
#   config file
#   add comments for all niche cases in script
#   commit matching with git builds
#   multi build kernels
#       multi kernel build - debug and regular, from one invocation
#       single build, either debug or regular

class Build:
    def __init__(self):
        self.__MIN_KERNEL_VERSION = '4.17.0'
        self.__MIN_ZFS_VERSION = '0.8.0'

        atexit.register(self.remove_tmpdir)

        self.__tmpdir = Path(tempfile.mkdtemp())
        Path.chmod(self.__tmpdir, 0o777)

        self.__kernel_src = Path.resolve(kernel.get_kernel_dir())
        self.__kernel_config = Path() / self.__kernel_src / '.config'

        if not Path.is_file(self.__kernel_config):
            utils.die(msg='ERROR: no config in kenrel directory')

        self.__use_zfs_release_version = True
        self.__use_zfs_local_ebuild = False

        self.__run_kernel_bump = False
        self.__force_bump_check = False

        self.__cc_use_clang = True
        self.__use_local_distdir = False
        self.__experimental = False
        self.__gentoo_repo_path = None
        self.__clean_kernel_src = True

        self.__zfs_ebuild = 'sys-fs/zfs-kmod'
        self.__zfs_ebuild_path = None
        self.__zfs_version = None
        self.__zfs_kmod_build_path = None

        self.__run_intro = True
        self.__run_intro_extra = False

        self.__run_zfs_checks = True
        self.__run_zfs_build = True
        self.__run_kmod_build = False

        self.__run_kernel_build = True
        self.__run_kernel_post = True
        self.__run_kernel_install = True

        self.__run_emerge = False

        self.__kernel_has_module_support = False

        # gets module version for 'dracut -k' and versioned storage path for saved work
        self.__kernel_module_dir = Path(self.__kernel_src).name[6:]
        if 'rc' not in self.__kernel_module_dir:
            # stable
            # ignore point releases and only care about minor version
            self.__zfs_src_storage_scheme = self.__kernel_module_dir.rpartition('.')[0]
        else:
            # release candidate
            # intentionally treat each rc as a seperate release
            self.__zfs_src_storage_scheme = self.__kernel_module_dir
            # fun shit
            # modules naming scheme is x.x.x-rcx but gentoo naming is x.x-rcx
            # i.e. 5.7-rc1 -> 5.7.0-rc1
            kver_tmp = self.__kernel_module_dir.rpartition('-')
            self.__kernel_module_dir = f'{kver_tmp[0]}.0{kver_tmp[1]}{kver_tmp[2]}'

        self.min_supported_version_check(checking='kernel', ver=self.__kernel_module_dir.partition('-')[0])

        self.__storage = Path() / os.environ['XDG_DATA_HOME'] / 'kernel'
        # self.__settings = Path() / os.environ['XDG_CONFIG_HOME'] / 'kernel/config'
        self.__storage_distfiles = Path() / self.__storage / 'distfiles'
        self.__storage_kernel_base = Path() / self.__storage / 'kernels'
        self.__storage_kernel_individual = Path() / self.__storage_kernel_base / self.__zfs_src_storage_scheme
        self.__kernel_switch_config = Path() / self.__storage_kernel_individual / '.config'
        self.__zfs_kmod_archive = Path('zfs.tar.zst')
        self.__zfs_kmod_src = Path() / self.__storage_kernel_individual / self.__zfs_kmod_archive

        if not Path.is_file(self.__kernel_switch_config):
            self.__force_bump_check = True

    def intro(self):
        print(f'kernel             : {self.__kernel_src}')
        print(f'Using LLVM/Clang   : {self.__cc_use_clang}')
        print(f'Install            : {self.__run_kernel_install}')
        print(f'ZFS version        : {self.__zfs_version}')
        print(f'ZFS local ebuild   : {self.__use_zfs_local_ebuild}')
        print(f'Configure kmod     : {self.__run_kmod_build}')
        print(f'Enable modules     : {self.__kernel_has_module_support}')
        print(f'Running emerge     : {self.__run_emerge}')
        if self.__run_intro_extra:
            print(f'EXTRA')
            print(f'Min kernel version : {self.__MIN_KERNEL_VERSION}')
            print(f'Min ZFS version    : {self.__MIN_ZFS_VERSION}')
            print(f'Make command       : {self.run_compiler(return_only=True)}')
            print(f'PORTDIR            : {self.__gentoo_repo_path}')
            print(f'kernel storage dir : {self.__storage_kernel_individual}')
            print(f'kernel module dir  : /lib/modules/{self.__kernel_module_dir}')
            print(f'Tempdir            : {self.__tmpdir}')
            print(f'Experimental opts  : {self.__experimental}')
            utils.run_cmd('eselect kernel list')
        print()
        input('Enter to start kernel build ')

    def min_supported_version_check(self, checking, ver):
        required = None
        if checking == 'kernel':
            required = self.__MIN_KERNEL_VERSION
        elif checking == 'zfs':
            required = self.__MIN_ZFS_VERSION

        if version.parse(required) > version.parse(ver):
            utils.die(msg=f'Minimum supported {checking} version is: {required}, using {ver}')

    def cdkdir(self):
        os.chdir(self.__kernel_src)

    def cdtmp(self):
        os.chdir(self.__tmpdir)

    def msc(self):
        self.run_compiler(act='syncconfig')

    def remove_tmpdir(self):
        shutil.rmtree(self.__tmpdir)

    def storage_check(self):
        if not Path.is_dir(self.__storage):
            Path(self.__storage).mkdir(parents=True, exist_ok=True)

        if not Path.is_dir(self.__storage_distfiles):
            Path(self.__storage_distfiles).mkdir(parents=True, exist_ok=True)

        if not Path.is_dir(self.__storage_kernel_individual):
            Path(self.__storage_kernel_individual).mkdir(parents=True, exist_ok=True)

    def modules_check(self):
        if not self.__kernel_has_module_support:
            for line in Path.open(self.__kernel_config):
                if 'CONFIG_MODULES=y' in line:
                    self.__kernel_has_module_support = True

    def run_compiler(self, act='', force_gcc=False, return_only=False):
        # keep CC/LD to override env, probably not needed though
        cores = multiprocessing.cpu_count()
        cc = ''
        ld = ''
        kmake = f'sh -c "'
        if not self.__cc_use_clang or force_gcc:
            # gcc
            cc = 'gcc'
            ld = 'ld.bfd'
        elif self.__cc_use_clang:
            # clang
            cc = 'clang'
            ld = 'ld.lld'
            kmake += f'LLVM=1 '
            if self.__experimental:
                kmake += 'LLVM_IAS=1 '

        kmake += f'nice -19 make -j{cores * 2 + 1} -l{cores + 1} CC={cc} LD={ld} {act}"'
        if return_only:
            return kmake

        utils.run_cmd(kmake)

    def kernel_bump(self):
        # CONFIG_MODULES and CONFIG_KALLSYMS are required to build zfs
        # but are not needed at runtime if zfs is build into the kernel.
        kernel.kernel_conf_copy(src=self.__kernel_src, dst=self.__tmpdir)
        while True:
            c1, c2, c3 = False, False, False
            for line in Path.open(self.__kernel_config):
                if 'CONFIG_MODULES=y' in line:
                    c1 = True
                if 'CONFIG_TRIM_UNUSED_KSYMS=y' in line:
                    c2 = False
                if 'CONFIG_KALLSYMS=y' in line:
                    c3 = True

            if not (c1 or c2 or c3):
                print('\nRequired option[s] located at:\n')
                if not c1:
                    print('\n[*] Enable loadable module support')
                if not c2:
                    print('\n[*] Enable loadable module support')
                    print('\t[ ]   Enable unused/obsolete exported symbols')
                    print('\t\t[ ]     Trim unused exported kernel symbols')
                if not c3:
                    print('\nGeneral setup  --->')
                    print('\t[*] Configure standard kernel features (expert users)  --->')
                    print('\t\t[*] Load all symbols for debugging/ksymoops')

                input('Enter to config switch config: ')

                if Path.is_file(self.__kernel_switch_config):
                    Path.unlink(self.__kernel_switch_config)
                self.cdkdir()
                self.run_compiler(act='nconfig')
            else:
                break

        kernel.kernel_conf_move(src=self.__kernel_config, dst=self.__kernel_switch_config)
        kernel.kernel_conf_copy(src=self.__tmpdir, dst=self.__kernel_src)
        utils.die(msg='\n\nSwitch config created, rerun script\n', exit_code=0)

    def zfs_checks(self):
        if self.__use_zfs_local_ebuild:
            repo_conf = 'local.conf'
        else:
            repo_conf = 'gentoo.conf'

        for line in Path.open(Path() / '/etc/portage/repos.conf' / repo_conf):
            if 'location' in line:
                self.__gentoo_repo_path = line.split()[2]
                break

        if self.__use_zfs_release_version:
            wanted_ebuild = None
            zfs_ebuild_path = Path() / self.__gentoo_repo_path / self.__zfs_ebuild
            for ebuild in Path(zfs_ebuild_path).iterdir():
                ebuild = str(ebuild)
                if ebuild.endswith('.ebuild') and not ebuild.endswith('9999.ebuild'):
                    wanted_ebuild = ebuild

            self.__zfs_version = wanted_ebuild.rpartition('.')[0].rpartition('-')[-1]

            # build path
            self.__zfs_kmod_build_path = "zfs"
            self.min_supported_version_check(checking='zfs', ver=self.__zfs_version)
        else:
            # git
            self.__zfs_version = '9999'
            # build path
            self.__zfs_kmod_build_path = 'zfs-kmod'

        self.__zfs_ebuild_path = Path() / self.__gentoo_repo_path / self.__zfs_ebuild / f'zfs-kmod-{self.__zfs_version}.ebuild'
        if not Path.is_file(self.__zfs_ebuild_path):
            utils.die(msg=f'ERROR: missing \'{self.__zfs_ebuild_path}\'')

        if not Path.is_file(self.__zfs_kmod_src) and self.__run_zfs_build:
            # need to build if configured src do not exists
            self.__run_kmod_build = True

    def build_zfs(self):
        zver_path = self.__zfs_version

        if 'rc' in self.__zfs_version:
            # rc ebuilds
            self.__zfs_version = self.__zfs_version.rpartition('_')[0]
        if '-r' in self.__zfs_version:
            # rev bump ebuilds
            self.__zfs_version = self.__zfs_version.rpartition('-')[0]

        if self.__run_kmod_build:
            self.cdkdir()
            self.msc()

            if not self.__kernel_has_module_support:
                if Path.is_file(self.__kernel_switch_config):
                    kernel.kernel_conf_move(src=self.__kernel_src, dst=self.__tmpdir)
                    kernel.kernel_conf_copy(src=self.__kernel_switch_config, dst=self.__kernel_src)
                else:
                    utils.die(msg=f'ERROR: missing switch config \'{self.__kernel_switch_config}\'')

            # need to use gcc for this
            self.run_compiler(act='prepare', force_gcc=True)

            if Path.is_file(self.__zfs_kmod_src):
                Path.unlink(self.__zfs_kmod_src)

            portage_env = f'export PORTAGE_TMPDIR="{self.__tmpdir}"\n'
            if self.__use_local_distdir:
                portage_env += f'export DISTDIR="{self.__storage_distfiles}"\n'

            zfs_build_path = Path() / self.__tmpdir / 'portage' / f'{self.__zfs_ebuild}-{zver_path}' / 'work'
            zfs_build_version = f'{self.__zfs_kmod_build_path}-{self.__zfs_version}'

            # this is just simpler
            script = f'{self.__tmpdir}/tmp.sh'
            text = f'{portage_env}\n' \
                   f'EXTRA_ECONF="--with-linux={self.__kernel_src} --enable-linux-builtin" ebuild ' \
                   f'{self.__zfs_ebuild_path} configure || die "build failed"\n' \

            utils.write_script_shell(script, text)
            utils.run_cmd(script)

            os.chdir(Path() / zfs_build_path / zfs_build_version)
            utils.run_cmd(f'./copy-builtin {self.__kernel_src}')
            os.chdir(zfs_build_path)
            utils.run_cmd(f'mkzst {zfs_build_version}')
            shutil.move(Path(f'{zfs_build_version}.tar.zst'),
                        Path() / self.__zfs_kmod_src)

            if not self.__kernel_has_module_support:
                kernel.kernel_conf_move(src=self.__tmpdir, dst=self.__kernel_src)

            if self.__cc_use_clang:
                # when using clang to run 'make prepare' get error when running zfs configure
                # 'Unable to build an empty module.'
                # so clean kernel src since gcc was used in prepare
                utils.run_cmd('kernel-clean-src -c')

        else:
            if not Path.is_file(self.__zfs_kmod_src):
                utils.die(msg=f'Archive missing: {self.__zfs_kmod_src}')

            shutil.copyfile(Path() / self.__storage_kernel_individual / self.__zfs_kmod_archive,
                            Path() / self.__tmpdir / self.__zfs_kmod_archive)
            os.chdir(self.__tmpdir)
            utils.run_cmd(f'extract {self.__zfs_kmod_archive}')
            os.chdir(Path() / self.__tmpdir / f'{self.__zfs_kmod_build_path}-{self.__zfs_version}')
            utils.run_cmd(f'./copy-builtin {self.__kernel_src}')

    def build_kernel(self):
        self.cdkdir()
        self.msc()
        self.run_compiler()

        if self.__run_kernel_install:
            if self.__kernel_has_module_support:
                self.run_compiler(act='modules_install')
            self.run_compiler(act='install')

        if self.__run_kernel_post:
            if self.__run_emerge:
                if self.__run_kmod_build:
                    if self.__use_zfs_release_version:
                        utils.run_cmd('emerge --ignore-default-opts --oneshot --quiet --update sys-fs/zfs')
                    else:
                        # will always rebuild zfs when using git
                        utils.run_cmd('emerge --ignore-default-opts --oneshot --quiet sys-fs/zfs')
                if self.__kernel_has_module_support:
                    utils.run_cmd('emerge --ignore-default-opts --oneshot --jobs @module-rebuild')
            utils.run_cmd(f'kernel-initramfs-dracut -k {self.__kernel_module_dir}')
            utils.run_cmd('kernel-grub')
            if self.__clean_kernel_src:
                utils.run_cmd('kernel-clean-src -c')

    def build(self):
        self.modules_check()
        self.storage_check()

        if self.__run_zfs_checks:
            self.zfs_checks()
        if self.__run_intro:
            self.intro()
        if self.__run_kernel_bump or self.__force_bump_check:
            self.kernel_bump()
        if self.__run_zfs_build:
            self.build_zfs()
        if self.__run_kernel_build:
            self.build_kernel()

    def run(self, args):
        # General
        if args.force_no_bump:
            self.__force_bump_check = False
        if args.force_bump:
            self.__force_bump_check = True
        if args.edit:
            utils.not_implemented()
            # utils.edit_conf(self.__settings)
        if args.reset_config:
            utils.not_implemented()
            # Path.unlink(self.__settings)
        if args.rm_built_src:
            if Path.is_dir(self.__storage_kernel_base):
                shutil.rmtree(self.__storage_kernel_base)
            if Path.is_dir(self.__storage_distfiles):
                shutil.rmtree(self.__storage_distfiles)
            utils.die()
        if args.no_intro:
            self.__run_intro = False
        if args.verbose:
            self.__run_intro_extra = True
        # ZFS
        if args.force_rebuild_kmod:
            self.__run_kmod_build = True
        if args.local_distdir:
            self.__use_local_distdir = True
        if args.use_git:
            self.__use_zfs_release_version = False
        if args.use_release:
            self.__use_zfs_release_version = True
        if args.use_local_ebuild:
            self.__use_zfs_local_ebuild = True
        # Kernel
        if args.compiler:
            self.__cc_use_clang = False
        if args.no_clean:
            self.__clean_kernel_src = False
        if args.emerge:
            self.__run_emerge = True
        if args.no_install:
            self.__run_kernel_post = False
            self.__run_kernel_install = False
        if args.modules:
            self.__kernel_has_module_support = True
        if args.no_post:
            self.__run_kernel_post = True
        if args.fancy_make:
            self.__run_zfs_checks = False
            self.__run_zfs_build = False
        if args.zfs_install:
            self.__run_zfs_build = True
            self.__run_kernel_build = False
        if args.experimental:
            self.__experimental = True

        self.build()


def main():
    parser = argparse.ArgumentParser()
    general = parser.add_argument_group('GENERAL')
    general.add_argument('-b', '--force-no-bump',
                         action='store_true',
                         help='force disable kernel bump check')
    general.add_argument('-B', '--force-bump',
                         action='store_true',
                         help='force enable kernel bump check')
    general.add_argument('-E', '--edit',
                         action='store_true',
                         help='Edit config file')
    general.add_argument('-I', '--no-intro',
                         action='store_true',
                         help='disable intro')
    general.add_argument('-R', '--reset-config',
                         action='store_true',
                         help='reset config file and exit')
    general.add_argument('--rm-built-src',
                         action='store_true',
                         help='Remove generated \'distfiles\' and \'kernels\' dirs')
    general.add_argument('-v', '--verbose',
                         action='store_true',
                         help='set verbose on')
    zfs = parser.add_argument_group('ZFS')
    zfs.add_argument('-c', '--force-rebuild-kmod',
                     action='store_true',
                     help='build kmod even if preconfigured sources exist')
    zfs.add_argument('-d', '--local-distdir',
                     action='store_true',
                     help='use $XDG_DATA_DIR/kenrel/distfiles as $DISTDIR, does not work with FEATURES=userfetch')
    zfs.add_argument('-g', '--use-git',
                     action='store_true',
                     help='use git ebuild')
    zfs.add_argument('-r', '--use-release',
                     action='store_true',
                     help='use release ebuild')
    zfs.add_argument('-l', '--use-local-ebuild',
                     action='store_true',
                     help='use local repo in $PORTDIR_OVERLAY')
    ker = parser.add_argument_group('KERNEL')
    ker.add_argument('-G', '--compiler',
                     action='store_true',
                     help='build kernel using gcc')
    ker.add_argument('-C', '--no-clean',
                     action='store_true',
                     help='disable cleaning kernel source dir')
    ker.add_argument('-e', '--emerge',
                     action='store_true',
                     help='enable running emerge in post')
    ker.add_argument('-i', '--no-install',
                     action='store_true',
                     help='build kernel but do not install or run post, implies -p')
    ker.add_argument('-m', '--modules',
                     action='store_true',
                     help='force enable module build')
    ker.add_argument('-p', '--no-post',
                     action='store_true',
                     help='disable post, emerge, initramfs, and grub configure')
    ker.add_argument('-x', '--fancy-make',
                     action='store_true',
                     help='disable zfs build, becomes fancy \'make;make install\'')
    ker.add_argument('-z', '--zfs-install',
                     action='store_true',
                     help='only run zfs build, will install zfs into kenrel tree')
    ker.add_argument('-Z', '--experimental',
                     action='store_true',
                     help='enables experimental options, may or may not do something, or even work')

    args = parser.parse_args()

    utils.is_root()

    run = Build()
    run.run(args)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        exit()
